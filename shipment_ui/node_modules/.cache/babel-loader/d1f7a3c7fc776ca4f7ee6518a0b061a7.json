{"ast":null,"code":"import { contract_address, contract_abi } from \"./contract_config\"; // import { Web3 } from \"web3\";\n// import { aliceAddress } from \"./wallet\";\n\nimport { FetchAccount } from '../components/MetaMaskFetch';\nimport { toast } from 'react-toastify';\nimport 'react-toastify/dist/ReactToastify.css';\n\nconst Web3 = require('web3');\n\nconst web3 = new Web3(Web3.givenProvider || \"http://localhost:8545\");\nconst sideChainContract = new web3.eth.Contract(contract_abi, contract_address);\n\nconst GetChannelDetails = async channelId => {\n  try {\n    var details = await sideChainContract.methods.getChannel(channelId).call();\n    let details_div = {\n      'Alice Id': details['alice']['id'],\n      'Alice Cash': details['alice']['cash'],\n      'Alice Input Flag': String(details['alice']['waitForInput']),\n      'Bob Id': details['bob']['id'],\n      'Bob Cash': details['bob']['cash'],\n      'Bob Input Flag': String(details['bob']['waitForInput']),\n      'Timeout': details['timeout'],\n      'Status': details['status'],\n      'Published Tx Count': details['publish_tx_count'],\n      'Money': details['money']\n    };\n    return details_div;\n  } catch (error) {\n    toast.error(\"contract details are tempered or connectivity issue\");\n    console.log(error);\n  }\n};\n\nconst FetchOtherParty = async (channelId, ownAddress) => {\n  try {\n    var details = await sideChainContract.methods.getChannel(channelId).call(); // console.log(details)\n\n    if (web3.utils.toChecksumAddress(ownAddress) === web3.utils.toChecksumAddress(details['alice']['id'])) {\n      return web3.utils.toChecksumAddress(details['bob']['id']);\n    } else {\n      return web3.utils.toChecksumAddress(details['alice']['id']);\n    }\n  } catch (error) {\n    toast.error(\"contract details are tempered or connectivity issue\");\n    console.log(error);\n  }\n};\n\nconst ChannelExists = async channelId => {\n  let details = await GetChannelDetails(channelId);\n  return /^0x0+$/.test(details['Alice Id']);\n};\n\nconst CreateNewChannel = async (channelId, theOtherParty, cash) => {\n  const sender = await FetchAccount();\n  console.log(sender, web3.utils.checkAddressChecksum(sender));\n\n  try {\n    var txHash = await sideChainContract.methods.openChannel(channelId, web3.utils.toChecksumAddress(theOtherParty)).send({\n      from: web3.utils.toChecksumAddress(sender),\n      value: web3.utils.toHex(web3.utils.toWei(cash, 'wei')),\n      gas: 200000\n    });\n    toast.success(\"New Channel Created - \" + channelId);\n    console.log('new channel created, txHash->', txHash.transactionHash);\n  } catch (error) {\n    toast.error(\"Channel open request reverted\");\n    console.log(error);\n  }\n};\n\nconst ChannelConfirm = async (channelId, cash) => {\n  try {\n    const sender = await FetchAccount();\n    let flag = await ChannelExists(channelId);\n\n    if (flag) {\n      toast.error(\"Channel with \".concat(channelId, \" doesn't exists\"));\n    } else {\n      var txHash = await sideChainContract.methods.confirm(channelId).send({\n        from: web3.utils.toChecksumAddress(sender),\n        value: web3.utils.toHex(web3.utils.toWei(cash, 'wei')),\n        gas: 200000\n      });\n      console.log('Channel Deposit Confirmed. txHash-> ', txHash.transactionHash);\n      toast.success(\"Deposit confirmed\");\n    }\n  } catch (error) {\n    console.log(error);\n    toast.error(\"Deposit Declined for Channel Id \".concat(channelId));\n  }\n};\n\nconst ChannelRefund = async (channelId, self) => {\n  try {\n    var txHash = await sideChainContract.methods.refund(channelId).send({\n      from: web3.utils.toChecksumAddress(self),\n      gas: 200000\n    });\n    toast.success('Channel Refund Confirmed');\n    console.log('Channel Refund Confirmed. txHash-> ', txHash.transactionHash);\n  } catch (error) {\n    toast.error(\"Channel Refund request reverted\");\n    console.log(error);\n  }\n};\n\nconst IsValidSignature = async (addr, channel_id, count, sender_balance, recipient_balance, signature) => {\n  try {\n    addr = web3.utils.toChecksumAddress(addr);\n    var flag = await sideChainContract.methods.isValidSignature(addr, channel_id, count, sender_balance, recipient_balance, signature).call();\n    return flag;\n  } catch (error) {\n    toast.error(\"contract details are tempered or connectivity issue or invalid arguments passed\");\n    console.log(error);\n  }\n};\n\nconst ChannelFinalizeClose = async (channelId, self) => {\n  try {\n    var txHash = await sideChainContract.methods.finalizeClose(channelId).send({\n      from: web3.utils.toChecksumAddress(self),\n      gas: 200000\n    });\n    toast.success('Channel Closed.');\n    console.log('Channel Closed. txHash-> ', txHash.transactionHash);\n  } catch (error) {\n    console.log(\"Channel finalizeClose request reverted\");\n    toast.error(\"Channel Close request reverted\");\n    console.log(error);\n  }\n};\n\nconst ChannelClose = async (channel_id, count, sender_balance, recipient_balance, signature, self) => {\n  try {\n    var txHash = await sideChainContract.methods.close(channel_id, count, sender_balance, recipient_balance, signature).send({\n      from: web3.utils.toChecksumAddress(self),\n      gas: 200000\n    });\n    console.log('Channel Close request proceed. txHash-> ', txHash.transactionHash);\n  } catch (error) {\n    console.log(\"Channel Closed request reverted\");\n    console.log(error);\n  }\n};\n\nconst GetReceipt = async () => {\n  console.log((await web3.eth.getTransactionReceipt(\"0xd67d8714e4998cce8d9f17a98d06e3f3adb268c3010dbb4c2e2dbe17015c9918\")));\n};\n\nasync function IsMyChannel(channelId, sender) {\n  try {\n    var details = await sideChainContract.methods.getChannel(channelId).call();\n\n    if (sender === details['alice']['id'] || sender === details['bob']['id']) {\n      console.log(true);\n      return true;\n    } else {\n      console.log(false);\n      return false;\n    }\n  } catch (error) {\n    console.log(\"contract details are tempered or connectivity issue\");\n    console.log(error);\n  }\n}\n\nfunction IsMyChannelStatic(alice, bob, sender) {\n  try {\n    sender = web3.utils.toChecksumAddress(sender);\n    if (sender === web3.utils.toChecksumAddress(alice) || sender === web3.utils.toChecksumAddress(bob)) return true;else return false;\n  } catch (error) {\n    console.log(\"web3 provider issue\");\n    console.log(error);\n  }\n}\n\nexport { GetChannelDetails, FetchOtherParty, ChannelExists, CreateNewChannel, ChannelConfirm, ChannelRefund, IsValidSignature, ChannelFinalizeClose, ChannelClose, GetReceipt, IsMyChannel, IsMyChannelStatic };","map":{"version":3,"sources":["/home/gaurava/work/learning/react/shipment/src/contract/contract_transaction.js"],"names":["contract_address","contract_abi","FetchAccount","toast","Web3","require","web3","givenProvider","sideChainContract","eth","Contract","GetChannelDetails","channelId","details","methods","getChannel","call","details_div","String","error","console","log","FetchOtherParty","ownAddress","utils","toChecksumAddress","ChannelExists","test","CreateNewChannel","theOtherParty","cash","sender","checkAddressChecksum","txHash","openChannel","send","from","value","toHex","toWei","gas","success","transactionHash","ChannelConfirm","flag","confirm","ChannelRefund","self","refund","IsValidSignature","addr","channel_id","count","sender_balance","recipient_balance","signature","isValidSignature","ChannelFinalizeClose","finalizeClose","ChannelClose","close","GetReceipt","getTransactionReceipt","IsMyChannel","IsMyChannelStatic","alice","bob"],"mappings":"AAAA,SAASA,gBAAT,EAA2BC,YAA3B,QAA+C,mBAA/C,C,CACA;AACA;;AACA,SAASC,YAAT,QAA6B,6BAA7B;AACA,SAASC,KAAT,QAAsB,gBAAtB;AACA,OAAO,uCAAP;;AAEA,MAAMC,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,IAAI,GAAG,IAAIF,IAAJ,CAASA,IAAI,CAACG,aAAL,IAAsB,uBAA/B,CAAb;AACA,MAAMC,iBAAiB,GAAG,IAAIF,IAAI,CAACG,GAAL,CAASC,QAAb,CAAsBT,YAAtB,EAAoCD,gBAApC,CAA1B;;AAEA,MAAMW,iBAAiB,GAAG,MAAOC,SAAP,IAAqB;AAC3C,MAAI;AACA,QAAIC,OAAO,GAAG,MAAML,iBAAiB,CAACM,OAAlB,CAA0BC,UAA1B,CAAqCH,SAArC,EAAgDI,IAAhD,EAApB;AACA,QAAIC,WAAW,GAAG;AACd,kBAAYJ,OAAO,CAAC,OAAD,CAAP,CAAiB,IAAjB,CADE;AAEd,oBAAcA,OAAO,CAAC,OAAD,CAAP,CAAiB,MAAjB,CAFA;AAGd,0BAAoBK,MAAM,CAACL,OAAO,CAAC,OAAD,CAAP,CAAiB,cAAjB,CAAD,CAHZ;AAId,gBAAUA,OAAO,CAAC,KAAD,CAAP,CAAe,IAAf,CAJI;AAKd,kBAAYA,OAAO,CAAC,KAAD,CAAP,CAAe,MAAf,CALE;AAMd,wBAAkBK,MAAM,CAACL,OAAO,CAAC,KAAD,CAAP,CAAe,cAAf,CAAD,CANV;AAOd,iBAAWA,OAAO,CAAC,SAAD,CAPJ;AAQd,gBAAUA,OAAO,CAAC,QAAD,CARH;AASd,4BAAsBA,OAAO,CAAC,kBAAD,CATf;AAUd,eAASA,OAAO,CAAC,OAAD;AAVF,KAAlB;AAYA,WAAOI,WAAP;AACH,GAfD,CAeE,OAAOE,KAAP,EAAc;AACZhB,IAAAA,KAAK,CAACgB,KAAN,CAAY,qDAAZ;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ,CApBD;;AAsBA,MAAMG,eAAe,GAAG,OAAOV,SAAP,EAAkBW,UAAlB,KAAiC;AACrD,MAAI;AACA,QAAIV,OAAO,GAAG,MAAML,iBAAiB,CAACM,OAAlB,CAA0BC,UAA1B,CAAqCH,SAArC,EAAgDI,IAAhD,EAApB,CADA,CAEA;;AACA,QAAIV,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BF,UAA7B,MAA6CjB,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BZ,OAAO,CAAC,OAAD,CAAP,CAAiB,IAAjB,CAA7B,CAAjD,EAAuG;AACnG,aAAOP,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BZ,OAAO,CAAC,KAAD,CAAP,CAAe,IAAf,CAA7B,CAAP;AACH,KAFD,MAGK;AACD,aAAOP,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BZ,OAAO,CAAC,OAAD,CAAP,CAAiB,IAAjB,CAA7B,CAAP;AACH;AACJ,GATD,CASE,OAAOM,KAAP,EAAc;AACZhB,IAAAA,KAAK,CAACgB,KAAN,CAAY,qDAAZ;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ,CAdD;;AAgBA,MAAMO,aAAa,GAAG,MAAOd,SAAP,IAAqB;AACvC,MAAIC,OAAO,GAAG,MAAMF,iBAAiB,CAACC,SAAD,CAArC;AACA,SAAO,SAASe,IAAT,CAAcd,OAAO,CAAC,UAAD,CAArB,CAAP;AACH,CAHD;;AAKA,MAAMe,gBAAgB,GAAG,OAAOhB,SAAP,EAAkBiB,aAAlB,EAAiCC,IAAjC,KAA0C;AAC/D,QAAMC,MAAM,GAAG,MAAM7B,YAAY,EAAjC;AACAkB,EAAAA,OAAO,CAACC,GAAR,CAAYU,MAAZ,EAAoBzB,IAAI,CAACkB,KAAL,CAAWQ,oBAAX,CAAgCD,MAAhC,CAApB;;AACA,MAAI;AACA,QAAIE,MAAM,GAAG,MAAMzB,iBAAiB,CAACM,OAAlB,CAA0BoB,WAA1B,CAAsCtB,SAAtC,EAAiDN,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BI,aAA7B,CAAjD,EACdM,IADc,CACT;AAAEC,MAAAA,IAAI,EAAE9B,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BM,MAA7B,CAAR;AAA8CM,MAAAA,KAAK,EAAE/B,IAAI,CAACkB,KAAL,CAAWc,KAAX,CAAiBhC,IAAI,CAACkB,KAAL,CAAWe,KAAX,CAAiBT,IAAjB,EAAuB,KAAvB,CAAjB,CAArD;AAAsGU,MAAAA,GAAG,EAAE;AAA3G,KADS,CAAnB;AAEArC,IAAAA,KAAK,CAACsC,OAAN,CAAc,2BAA2B7B,SAAzC;AACAQ,IAAAA,OAAO,CAACC,GAAR,CAAY,+BAAZ,EAA6CY,MAAM,CAACS,eAApD;AACH,GALD,CAKE,OAAOvB,KAAP,EAAc;AACZhB,IAAAA,KAAK,CAACgB,KAAN,CAAY,+BAAZ;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ,CAZD;;AAcA,MAAMwB,cAAc,GAAG,OAAO/B,SAAP,EAAkBkB,IAAlB,KAA2B;AAC9C,MAAI;AACA,UAAMC,MAAM,GAAG,MAAM7B,YAAY,EAAjC;AACA,QAAI0C,IAAI,GAAG,MAAMlB,aAAa,CAACd,SAAD,CAA9B;;AACA,QAAIgC,IAAJ,EAAU;AACNzC,MAAAA,KAAK,CAACgB,KAAN,wBAA4BP,SAA5B;AACH,KAFD,MAEO;AACH,UAAIqB,MAAM,GAAG,MAAMzB,iBAAiB,CAACM,OAAlB,CAA0B+B,OAA1B,CAAkCjC,SAAlC,EACduB,IADc,CACT;AAAEC,QAAAA,IAAI,EAAE9B,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BM,MAA7B,CAAR;AAA8CM,QAAAA,KAAK,EAAE/B,IAAI,CAACkB,KAAL,CAAWc,KAAX,CAAiBhC,IAAI,CAACkB,KAAL,CAAWe,KAAX,CAAiBT,IAAjB,EAAuB,KAAvB,CAAjB,CAArD;AAAsGU,QAAAA,GAAG,EAAE;AAA3G,OADS,CAAnB;AAEApB,MAAAA,OAAO,CAACC,GAAR,CAAY,sCAAZ,EAAoDY,MAAM,CAACS,eAA3D;AACAvC,MAAAA,KAAK,CAACsC,OAAN,CAAc,mBAAd;AACH;AACJ,GAXD,CAWE,OAAOtB,KAAP,EAAc;AACZC,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACAhB,IAAAA,KAAK,CAACgB,KAAN,2CAA+CP,SAA/C;AACH;AACJ,CAhBD;;AAkBA,MAAMkC,aAAa,GAAG,OAAOlC,SAAP,EAAkBmC,IAAlB,KAA2B;AAC7C,MAAI;AACA,QAAId,MAAM,GAAG,MAAMzB,iBAAiB,CAACM,OAAlB,CAA0BkC,MAA1B,CAAiCpC,SAAjC,EACduB,IADc,CACT;AAAEC,MAAAA,IAAI,EAAE9B,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BsB,IAA7B,CAAR;AAA4CP,MAAAA,GAAG,EAAE;AAAjD,KADS,CAAnB;AAEArC,IAAAA,KAAK,CAACsC,OAAN,CAAc,0BAAd;AACArB,IAAAA,OAAO,CAACC,GAAR,CAAY,qCAAZ,EAAmDY,MAAM,CAACS,eAA1D;AACH,GALD,CAKE,OAAOvB,KAAP,EAAc;AACZhB,IAAAA,KAAK,CAACgB,KAAN,CAAY,iCAAZ;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ,CAVD;;AAYA,MAAM8B,gBAAgB,GAAG,OAAOC,IAAP,EAAaC,UAAb,EAAyBC,KAAzB,EAAgCC,cAAhC,EAAgDC,iBAAhD,EAAmEC,SAAnE,KAAiF;AACtG,MAAI;AACAL,IAAAA,IAAI,GAAG5C,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6ByB,IAA7B,CAAP;AACA,QAAIN,IAAI,GAAG,MAAMpC,iBAAiB,CAACM,OAAlB,CAA0B0C,gBAA1B,CAA2CN,IAA3C,EAAiDC,UAAjD,EAA6DC,KAA7D,EAAoEC,cAApE,EAAoFC,iBAApF,EAAuGC,SAAvG,EAAkHvC,IAAlH,EAAjB;AACA,WAAO4B,IAAP;AACH,GAJD,CAIE,OAAOzB,KAAP,EAAc;AACZhB,IAAAA,KAAK,CAACgB,KAAN,CAAY,iFAAZ;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ,CATD;;AAWA,MAAMsC,oBAAoB,GAAG,OAAO7C,SAAP,EAAkBmC,IAAlB,KAA2B;AACpD,MAAI;AACA,QAAId,MAAM,GAAG,MAAMzB,iBAAiB,CAACM,OAAlB,CAA0B4C,aAA1B,CAAwC9C,SAAxC,EACduB,IADc,CACT;AAAEC,MAAAA,IAAI,EAAE9B,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BsB,IAA7B,CAAR;AAA4CP,MAAAA,GAAG,EAAE;AAAjD,KADS,CAAnB;AAEArC,IAAAA,KAAK,CAACsC,OAAN,CAAc,iBAAd;AACArB,IAAAA,OAAO,CAACC,GAAR,CAAY,2BAAZ,EAAyCY,MAAM,CAACS,eAAhD;AACH,GALD,CAKE,OAAOvB,KAAP,EAAc;AACZC,IAAAA,OAAO,CAACC,GAAR,CAAY,wCAAZ;AACAlB,IAAAA,KAAK,CAACgB,KAAN,CAAY,gCAAZ;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ,CAXD;;AAaA,MAAMwC,YAAY,GAAG,OAAOR,UAAP,EAAmBC,KAAnB,EAA0BC,cAA1B,EAA0CC,iBAA1C,EAA6DC,SAA7D,EAAwER,IAAxE,KAAiF;AAClG,MAAI;AACA,QAAId,MAAM,GAAG,MAAMzB,iBAAiB,CAACM,OAAlB,CAA0B8C,KAA1B,CAAgCT,UAAhC,EAA4CC,KAA5C,EAAmDC,cAAnD,EAAmEC,iBAAnE,EAAsFC,SAAtF,EACdpB,IADc,CACT;AAAEC,MAAAA,IAAI,EAAE9B,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BsB,IAA7B,CAAR;AAA4CP,MAAAA,GAAG,EAAE;AAAjD,KADS,CAAnB;AAEApB,IAAAA,OAAO,CAACC,GAAR,CAAY,0CAAZ,EAAwDY,MAAM,CAACS,eAA/D;AACH,GAJD,CAIE,OAAOvB,KAAP,EAAc;AACZC,IAAAA,OAAO,CAACC,GAAR,CAAY,iCAAZ;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ,CATD;;AAWA,MAAM0C,UAAU,GAAG,YAAY;AAC3BzC,EAAAA,OAAO,CAACC,GAAR,EAAY,MAAMf,IAAI,CAACG,GAAL,CAASqD,qBAAT,CAA+B,oEAA/B,CAAlB;AAEH,CAHD;;AAKA,eAAeC,WAAf,CAA2BnD,SAA3B,EAAsCmB,MAAtC,EAA8C;AAC1C,MAAI;AACA,QAAIlB,OAAO,GAAG,MAAML,iBAAiB,CAACM,OAAlB,CAA0BC,UAA1B,CAAqCH,SAArC,EAAgDI,IAAhD,EAApB;;AACA,QAAIe,MAAM,KAAKlB,OAAO,CAAC,OAAD,CAAP,CAAiB,IAAjB,CAAX,IAAqCkB,MAAM,KAAKlB,OAAO,CAAC,KAAD,CAAP,CAAe,IAAf,CAApD,EAA0E;AACtEO,MAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ;AACA,aAAO,IAAP;AACH,KAHD,MAGO;AACHD,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ;AACA,aAAO,KAAP;AACH;AACJ,GATD,CASE,OAAOF,KAAP,EAAc;AACZC,IAAAA,OAAO,CAACC,GAAR,CAAY,qDAAZ;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ;;AAGD,SAAS6C,iBAAT,CAA2BC,KAA3B,EAAkCC,GAAlC,EAAuCnC,MAAvC,EAA+C;AAC3C,MAAI;AACAA,IAAAA,MAAM,GAAGzB,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BM,MAA7B,CAAT;AACA,QAAIA,MAAM,KAAKzB,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6BwC,KAA7B,CAAX,IAAkDlC,MAAM,KAAKzB,IAAI,CAACkB,KAAL,CAAWC,iBAAX,CAA6ByC,GAA7B,CAAjE,EACI,OAAO,IAAP,CADJ,KAGI,OAAO,KAAP;AACP,GAND,CAME,OAAO/C,KAAP,EAAc;AACZC,IAAAA,OAAO,CAACC,GAAR,CAAY,qBAAZ;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACH;AACJ;;AAED,SACIR,iBADJ,EACuBW,eADvB,EACwCI,aADxC,EACuDE,gBADvD,EACyEe,cADzE,EACyFG,aADzF,EACwGG,gBADxG,EAEIQ,oBAFJ,EAE0BE,YAF1B,EAEwCE,UAFxC,EAEoDE,WAFpD,EAEiEC,iBAFjE","sourcesContent":["import { contract_address, contract_abi } from \"./contract_config\";\n// import { Web3 } from \"web3\";\n// import { aliceAddress } from \"./wallet\";\nimport { FetchAccount } from '../components/MetaMaskFetch';\nimport { toast } from 'react-toastify';\nimport 'react-toastify/dist/ReactToastify.css';\n\nconst Web3 = require('web3')\nconst web3 = new Web3(Web3.givenProvider || \"http://localhost:8545\")\nconst sideChainContract = new web3.eth.Contract(contract_abi, contract_address)\n\nconst GetChannelDetails = async (channelId) => {\n    try {\n        var details = await sideChainContract.methods.getChannel(channelId).call()\n        let details_div = {\n            'Alice Id': details['alice']['id'],\n            'Alice Cash': details['alice']['cash'],\n            'Alice Input Flag': String(details['alice']['waitForInput']),\n            'Bob Id': details['bob']['id'],\n            'Bob Cash': details['bob']['cash'],\n            'Bob Input Flag': String(details['bob']['waitForInput']),\n            'Timeout': details['timeout'],\n            'Status': details['status'],\n            'Published Tx Count': details['publish_tx_count'],\n            'Money': details['money']\n        }\n        return details_div;\n    } catch (error) {\n        toast.error(\"contract details are tempered or connectivity issue\")\n        console.log(error)\n    }\n}\n\nconst FetchOtherParty = async (channelId, ownAddress) => {\n    try {\n        var details = await sideChainContract.methods.getChannel(channelId).call()\n        // console.log(details)\n        if (web3.utils.toChecksumAddress(ownAddress) === web3.utils.toChecksumAddress(details['alice']['id'])) {\n            return web3.utils.toChecksumAddress(details['bob']['id'])\n        }\n        else {\n            return web3.utils.toChecksumAddress(details['alice']['id'])\n        }\n    } catch (error) {\n        toast.error(\"contract details are tempered or connectivity issue\")\n        console.log(error)\n    }\n}\n\nconst ChannelExists = async (channelId) => {\n    let details = await GetChannelDetails(channelId)\n    return /^0x0+$/.test(details['Alice Id']);\n}\n\nconst CreateNewChannel = async (channelId, theOtherParty, cash) => {\n    const sender = await FetchAccount()\n    console.log(sender, web3.utils.checkAddressChecksum(sender))\n    try {\n        var txHash = await sideChainContract.methods.openChannel(channelId, web3.utils.toChecksumAddress(theOtherParty))\n            .send({ from: web3.utils.toChecksumAddress(sender), value: web3.utils.toHex(web3.utils.toWei(cash, 'wei')), gas: 200000 })\n        toast.success(\"New Channel Created - \" + channelId)\n        console.log('new channel created, txHash->', txHash.transactionHash);\n    } catch (error) {\n        toast.error(\"Channel open request reverted\")\n        console.log(error)\n    }\n}\n\nconst ChannelConfirm = async (channelId, cash) => {\n    try {\n        const sender = await FetchAccount()\n        let flag = await ChannelExists(channelId)\n        if (flag) {\n            toast.error(`Channel with ${channelId} doesn't exists`)\n        } else {\n            var txHash = await sideChainContract.methods.confirm(channelId)\n                .send({ from: web3.utils.toChecksumAddress(sender), value: web3.utils.toHex(web3.utils.toWei(cash, 'wei')), gas: 200000 })\n            console.log('Channel Deposit Confirmed. txHash-> ', txHash.transactionHash);\n            toast.success(\"Deposit confirmed\")\n        }\n    } catch (error) {\n        console.log(error)\n        toast.error(`Deposit Declined for Channel Id ${channelId}`)\n    }\n}\n\nconst ChannelRefund = async (channelId, self) => {\n    try {\n        var txHash = await sideChainContract.methods.refund(channelId)\n            .send({ from: web3.utils.toChecksumAddress(self), gas: 200000 })\n        toast.success('Channel Refund Confirmed')\n        console.log('Channel Refund Confirmed. txHash-> ', txHash.transactionHash);\n    } catch (error) {\n        toast.error(\"Channel Refund request reverted\")\n        console.log(error)\n    }\n}\n\nconst IsValidSignature = async (addr, channel_id, count, sender_balance, recipient_balance, signature) => {\n    try {\n        addr = web3.utils.toChecksumAddress(addr)\n        var flag = await sideChainContract.methods.isValidSignature(addr, channel_id, count, sender_balance, recipient_balance, signature).call()\n        return flag\n    } catch (error) {\n        toast.error(\"contract details are tempered or connectivity issue or invalid arguments passed\")\n        console.log(error)\n    }\n}\n\nconst ChannelFinalizeClose = async (channelId, self) => {\n    try {\n        var txHash = await sideChainContract.methods.finalizeClose(channelId)\n            .send({ from: web3.utils.toChecksumAddress(self), gas: 200000 })\n        toast.success('Channel Closed.')\n        console.log('Channel Closed. txHash-> ', txHash.transactionHash);\n    } catch (error) {\n        console.log(\"Channel finalizeClose request reverted\")\n        toast.error(\"Channel Close request reverted\")\n        console.log(error)\n    }\n}\n\nconst ChannelClose = async (channel_id, count, sender_balance, recipient_balance, signature, self) => {\n    try {\n        var txHash = await sideChainContract.methods.close(channel_id, count, sender_balance, recipient_balance, signature)\n            .send({ from: web3.utils.toChecksumAddress(self), gas: 200000 })\n        console.log('Channel Close request proceed. txHash-> ', txHash.transactionHash);\n    } catch (error) {\n        console.log(\"Channel Closed request reverted\")\n        console.log(error)\n    }\n}\n\nconst GetReceipt = async () => {\n    console.log(await web3.eth.getTransactionReceipt(\"0xd67d8714e4998cce8d9f17a98d06e3f3adb268c3010dbb4c2e2dbe17015c9918\"))\n\n}\n\nasync function IsMyChannel(channelId, sender) {\n    try {\n        var details = await sideChainContract.methods.getChannel(channelId).call()\n        if (sender === details['alice']['id'] || sender === details['bob']['id']) {\n            console.log(true)\n            return true\n        } else {\n            console.log(false)\n            return false\n        }\n    } catch (error) {\n        console.log(\"contract details are tempered or connectivity issue\")\n        console.log(error)\n    }\n}\n\n\nfunction IsMyChannelStatic(alice, bob, sender) {\n    try {\n        sender = web3.utils.toChecksumAddress(sender)\n        if (sender === web3.utils.toChecksumAddress(alice) || sender === web3.utils.toChecksumAddress(bob))\n            return true\n        else\n            return false\n    } catch (error) {\n        console.log(\"web3 provider issue\")\n        console.log(error)\n    }\n}\n\nexport {\n    GetChannelDetails, FetchOtherParty, ChannelExists, CreateNewChannel, ChannelConfirm, ChannelRefund, IsValidSignature,\n    ChannelFinalizeClose, ChannelClose, GetReceipt, IsMyChannel, IsMyChannelStatic\n}"]},"metadata":{},"sourceType":"module"}